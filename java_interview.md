## 考察内存模型理解

### JDK&JVM&JRE 概念和区别

### JVM 对内存的抽象分为主要哪几区
1. heap (new 出来的对象存放位置）&& method area (It stores per-class structures such as the run-time constant pool, field and method data, and the code for methods and construct)
2. 线程私有隔离区：VM Stack, Native mathod stack, program counter register

### 堆又可以分为哪几个区？
young->Tenured(eden->survior->old gen)

### JVM如何做垃圾回收的？

答由垃圾回收器负责对各区进行回收，比如堆区的回收策略
	1) minor gc， 什么时候触发？ 当eden区满的时候
	2) major gc 
	3) full gc 什么时候触发？ 当老年代空间不足，方法区空间不足等

### Java是如何判断某对象是否可回收的？ 
答： 该对象到GC root节点是否存在引用路径可达
四种GC roots对象： （1） 虚拟机栈中的引用对象 （2）定义的全局静态对象 （3）常量引用 (4) JNI技术使用本地方法栈中的对象

### 有没有遇到过内存泄漏问题，如何解决的？

### 有没有遇到过性能问题，如何解决的？

1.缓存
2.异步调用

### 单例模式的实现几种方式

1. 静态final 字段
2. double check 双重锁的方式
3. 静态类内部类（延迟加载）
4. 枚举方式

## 考察数据结构

1. 链表和数组的区别： 时间和空间上谈， 对应其优缺点和应用场景

2. Java hashMap 是基于冲突链表实现的。 影响hash map的两个因素：初始容量（初始大小）和负载因素（自动扩容的临界值）  

3. 对于有hash冲突的键值对， 会存在冲突链表中， 新的值是插在链表头的

4. 高阶 hashset实现：由hashMap实现

5. 寻找数组中第K小的数

  1. 快排 n*logn
  2. 改进选择算法 一次选取K个数，从中选出Kmax 复杂度n*o(K)
  3. 算法2改进， 利用K个数的最大堆算法选出kmax, 复杂度n*logK
  4. 基于快排的改进算法
  	选取S中一个元素作为枢纽元v，将集合S-{v}分割成S1和S2，就像快速排序那样
如果k <= |S1|，那么第k个最小元素必然在S1中。在这种情况下，返回QuickSelect(S1, k)。
如果k = 1 + |S1|，那么枢纽元素就是第k个最小元素，即找到，直接返回它。
否则，这第k个最小元素就在S2中，即S2中的第（k - |S1| - 1）个最小元素，我们递归调用并返回QuickSelect(S2, k - |S1| - 1)。
此算法的平均运行时间为O(n)。

## 当一个UI 事件响应处理函数耗时过长时候 要注意什么？

## Jdk 8

### 什么是函数式编程?


## 考察操作系统

1. 线程和进程的区别
    1. 线程 share 内存， 独立的栈，局部变量，寄存器，程序计数器， 进程独占内存空间（从空间上）
    2. 线程是cpu是计算机调度的基本单位。
    3. 一个进程无法直接访问其他进程资源


## 机试题 （主要考察代码风格）
1.字符串过滤，对于一串字符串，若该字符串中间包含“*",去掉”*"后输出；若该字符串首字符或尾字符为“*",则保留该处的“*"；若该字符不包含”*"或包含其他字符，可直接输出


测试用例
 1. ""
 2. null
 3. "*www((***))*&&(*"
 4. "*www&&*"
 5. "*www"
 6. " we2 *"
 7. ***
 8. ****
 


